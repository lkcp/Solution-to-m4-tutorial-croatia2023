#+options: ^: nil

This is the solution to tutorial in [[https://github.com/mkannwischer/m4-tutorial-croatia2023][m4-tutorial-croatia2023]] .

* Install

** Install qemu
#+begin_src shell
  brew install qemu
#+end_src


* Pre-tutorial instructions

Please make sure that the 'helloworld' example successfully outputs

#+begin_src shell
Hello Croatia 2023!
#+end_src

when run in qemu prior to attending the tutorial.
Installation instructions are available above.

You can build and run the example using the following steps:

#+begin_src shell
cd helloworld
make
make run-qemu
#+end_src

* Note
** Cortex-M4
1. Armv7E-M architecture, released in 2010,
2. stages (fetch, decode, execute), branching breaks pipeline (consider also branch prediction and speculative execution)
3. r0-r15, r13 (sp, stack pointer), r14 (lr, link register), r15 (pc, program counter), r0-r12 are general purpose, and r14 can also be freely used after being saved to the stack
4. Instr Rd, Rn(, Rm), many instructions have a variant that sets flags by appending s
5. *barrel shifter*
   ARM 独有的特征，是一种常见的优化方法，实现一条指令实现两条指令的效果，仅花费一个周期。
   例如
   #+begin_src asm
     mov r0 , #42
     mov r1 , #37
     ror r1 , r1 , #1
     orr r2 , r0 , r1
     lsl r2 , r2 , #1
     eor r0 , r2
   #+end_src
   又可以以这种优化的方式实现
   #+begin_src asm
  mov r0, #42
  mov r1, #37
  orr r2, r0, r1, ror #1
  eor r0, r2, r2, lsl #1
   #+end_src
    barrel shifter 不会更新 Rm 中的值，只是会得到临时的结果用于 Instr
6. conditional branchs
   cmp r0, r1/immediate
   bxx label, jump with flag corresponding to xx (\==, !=, >, >=, <, <=)
7. conditional execution
   if-then-else(ITE), up to 4 instructions
8. stack
   Used when data does not fit in registers, push {r0, r1}, pop {r0, r2} (assigned register by user)
9. memory
10. memory pipeline
    - a single ldr take 2 cycles (when not stalled), N consecutive ldr take N+1 cycles
    - str takes 1 cycle, does not pipeline
    - ldrd/strd/ldm/stm do not pipeline, takes N+1 cycles when load N words
    - For more details look at https://developer.arm.com/documentation/ddi0439/b/Programmers-Model/Instruction-set-summary/Load-store-timings
11. lr keep track of 'return address'
12. arguments of function
    通过 r0-r3 用于存储实参，如果多于 4 个参数，则先将第五个参数存在 r0 中再将 r0 压入栈中。也就是在最右边的会先被压入栈。
    long 和 double 类型的参数需要使用两个寄存器存储
13. AAPCS (ARM Architecture Procedure Call Standard)
* Assignments
** IN-PREGRESS chacha20
当运行参考实现时， qemu 上的执行时间大致在这附近波动

#+begin_quote
====== START ======
crypto_stream_chacha20: 19300 cycles (note that these are meaningless on qemu)
OK chacha20
====== END ======
#+end_quote

*** Write quarterround function in assembly
实现这部分初步体会到了 berrel shift 的妙用，对于一块操作，如
#+begin_src c
  *a = *a + *b;
  *d = *d ^ *a;
  *d = rotate(*d, 16);
#+end_src
我最开始的设想是，

#+begin_src asm
  mov r8, r7, lsr #16
  mov r7, r7, lsl #16
  eor r7, r7, r8
#+end_src

我觉得已经充分使用了，但是随后又发现其实还可以减少一个周期，变为

#+begin_src asm
  mov r8, r7, lsr #16
  eor r7, r8, r7, lsl #16
#+end_src

总的来说，是把原本一个 5 cycles 的操作变为了 2 cycles.

经过这部分优化之后，执行时间降低到 16000 附近
#+begin_src shell
====== START ======
crypto_stream_chacha20: 17375 cycles (note that these are meaningless on qemu)
OK chacha20
====== END ======
#+end_src

*** Merge 4 quarterround functions into a full round
初步的想法就是将 16 个32比特的状态作为参数传入，然后根据实参来决定执行前4个后后嗣个 quarterround。只要指定好每次传入的实参，那其实就是同样的操作执行4次。不过多余的参数已经被压入栈了，所以每操作完四个参数，再从栈中 pop 出随后要处理的4个参数即可。

但是在执行时出现了 HardFault_Handler, 检查了一下 mps2.ld, 栈大小是 0x400 也就是 1kB, 所以不是栈的问题。

应该是 pop 的问题。是这样的，调用函数时先把参数从又开始压至栈中，再执行 push {r4-r11, lr}, 所以参数的地址实际上在 sp + 9*4 的位置，我通过 gdb 进行 debug 发现的确如此。经过调整后结果正确，不再有问题。

#+begin_src shell
  ====== START ======
  crypto_stream_chacha20: 16800 cycles (note that these are meaningless on qemu)
  OK chacha20
  ====== END ======
#+end_src

*** DONE Later: Implement loop over 20 rounds in assembly
也就是把 20 轮循环打包成单个函数，再加一个 flag 和循环跳转。不过这次不再能手动指定寄存器的位置，所以需要一些额外的寄存器来存储地址。因为每一行的第一个值都是 x0-x3, 所以就按照 x0-x15 的顺序传参，这样一来， x0-x3 在一开始存在寄存器中，每次只需要到栈中取一次地址，然后存储在 r10, r11, r14 三个寄存器中。遵循前面的习惯，以 r4-r7 存储四个传入的值，r8 存储计算过程中的中间值。为了使用循环，还需要使用一个寄存器 r9 存储计数器。这一步也比较简单。不过在执行时间上未体现出明显的优势。按理说这里少了许多的 push 和 pop, 应该能节约很多时间。
** Dilithium
** Kyber
